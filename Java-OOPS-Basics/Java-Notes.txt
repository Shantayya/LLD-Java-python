Day0: OOPS concepts
---Java source file structure-----
1. java file can contain any number of classes.
2. you can provide any name to java file in above case.But if java file contains public class then java ffile name must be public class name. 
3. atmax only one public class must be there in java file.
4. java file containing number of classes with main methods so after compiling number of .class files will be created with class names so we can run class specific file.

-----Import statment-----
1. Explicit import: import java.util.ArrayList;
Always use this for readability
2. Implicit import: import java.util.*;

Package: group of related classes and interfaces. In any java file atmost one package statements allowed. 
package com.shantayya.ocja	--> these are unique and referrenced from internet domain name from reverse order

Day1:
Encapsulation 	= Data Hiding 	+ Abstraction

Enscapsulation = process of binding the data members and its behaviours. 
Data Hiding = hiding the data member from outside world using private access modifier.
Abstraction = representing only required services to client without showing internal working of it. (GUI)

Public class Account{							________________________	
	private double bal;		--> data hiding			|Bank of India	ATM	|	
	public double getBal(){					---> 	|			|
		return bal;	<------------------------------------ 	|Check Bal 		|
	}				Abstraction			|
   }									|Update Bal		|
									|_______________________|	
Every class is an encapsulation. 
Tightly encapsulated class if and only if all data members are private. 


Day2:
Is-a-relationship (Inheritance):
1. implement using extends keyword
2. main advantage is code reusability.(example: Loan --> Vloan,HLoan,Ploan etc 900 methods 90hrs 250 are common)
3. Java does not support for multiple inheritance in class due to ambiguity problem. But the same is not the case in interface. we can implement multiple inheritance in interface bcz interface contains only declaration and there is single implementation available. 

public class P{
	public void m(){
		Sopln("Parent");
	}
}
public C extends P{
	public void m1(){
       Sopln("Child");
	}
}

Public Static class Client{
   p.s.v.m(String[] args){
    P p = new P();		---> creating parents class obj
    p.m();
    p.m1();	---> error: cannot find symbol m1 in Parent class
 
    P p1 = new C();
    p1.m();
    p1.m1();	--> error: incompatible type found P required C. 
We can use parent referrence for child obj but even though we can only call parent methods. Big advatage of creating parent referrence with child obj is polymorphism. 

    C c = new C();
    c.m();	---> inheritance. child can automatically inherit parent properties. 
    c.m1();

    C c = new P(); --> error
 }
}


Day3:
Has-a-relationship(Composition/Aggregation):

public class Engine{
	// engine specific funcationality
}
public class car{
 Engine e = new Engine()
}

Here in above example car has a relatinship with engine. by creating engine obj in car class we can use all engine functinalities in car. 
No specific keyword is used in composition. mostly new() used. 
code reusability is main advatage. 

composition vs aggregation: 
without existance of container obj(university) there may not be existance of contained obj(dept). and this strong association between container obj and contained obj called composition. 

without exiatnce of container obj(dept) there can be existance of contained obj(professors). so this weak association between container and contained obj called aggregation. 


--> method signature in java: method name followed by argument type. no return type part of it. 
m1(int,float)
Note: In a class 2 methods with same signature not allowed. even though return type is diff. it throws error bcz method signature des not contain return type. 


Day4
Overloading: same method name with different argument types. 
class Test{

 public void m1(int a){
	sopln("int m1")
 }
 public void m1(float a){
   sopln("Float m1")
 }
}
public client{
p.s.v.m(String[] args){
 Test t = new Test();
 t.m1(10);	--> m1(int)
 t.m1(10.4f);	--> m1(float)
 t.m1('a');	--> m1(int)	auto promotion
 t.m1(100l);	--> m1(float)
 t.m1(100.99);	--> compile error
 }
}

We can see t.m1('a') will execute bcz of automatic promotion in overloading. java checks for exact match in overloading however if does not find so java will not throw immediate compile time error rather looks for next higher args type method
and consider if available otherwise error. 

char -------> int --> long---> float --> double
	       ^	(automatic promotion in overloading)
byte--> short -^ 

Note: while resolving method overloading, java always give priority to child type args compared with parent class. 
A(Object o){} , A(String s){} --> in main class{ A(null) --> call child type args--> A(String s)
we will get compile time error if 2 child type args will be there like String and StringBuffer.


Day5: 
Overriding: parent class method is redefined in child class. late binding/dynamic polimorphism/runtime polymorphism
P p = new C();
p.marry()	--> at compile time java checks does parent class has marry method or not if yes then proceed--> 
jvm at run time java checks p is of child obj so it calls marry method of child class if no marry method in child then error

overriding rules:
1. co-varient(child class) return type can be different 
2. same private method can be defined in child class as parent which is valid but its not overriding. 
3. final parent methods are not allowed to override
4. abstract parent to non-abstract and non-abstract parent to abstract child method overriding is allowed. 
abstract class P{			 class P{
 public abstract void m();			 	public void m();
  }						}
class C extends P{			  abstract class C extends P{
 public void m{						public abstract void m();
 }							}
					  class D extends C{
  						public void m(){
						}
					   }
5. all child classes of Runtime Exception and Error are unchecked exceptions and remaining all are checked
6. If child class throws checked exception then parent class must throw the same checked exception or its parent, if not compile time error comes. But there are no restrictions for unchecked exceptions. 
7. We cannot override static method as non-static
8. parent method is non-static and if child method is static then overriding is not allowed. 
9. when child and parent class have static method then its not method overriding rather method hiding. 
method resolution takes care by compiler in method hiding. 
10. overriding is allowed only for methods not for data members. (Var resolution is always takes care by compiler)

Method hiding					Method overriding
both static					non-static
compile time					run time execution
both methods available				only child methods available



properties				Overloading				Overriding
1. method signature			must be different 			must be same
2. return types				no rules				co-varient return typees allowed
3. private,static,final methods		Can be overloaded			Cannot be overridden
4. Access modifiers			N restrictions 				Scope of modifiers cannot be reduced but can be increased
5. throws claus				No restriction				If child class method throws checked exception the parent method must throw same 										checked exception or its parent exception else throws error.
6. Method resolution			compile time				run time
					based on referrence type		based on object type

polymorphism: one form but multiple implementation 

AL al = new AL()					List l = new AL()
child class referrence to child obj			parent class referrence to child class obj
can call any method from child + parent			can only call method from parent
can hold only AL obj					can hold any child type obj like AL,LL,Vector etc
if sure about runtime obj type				if not sure about runtime obj type
						

				OOPS
Encapsulation			Polymorphism			Inheritance		---> 3 pillers 
(security)			(Flexibility)			(code-reusability)


Day6: Coupling (degree of dependancy between components)
cohesion: clear funcationlity defined for component

object type-casting: use parent referrence to hold child object. 
Object o = new String("Hello");

we can use Interface referrence to hold implemented class object. 
Runnable r = new Thread();

A			a		= 	(C)			d
class/Interface	 name of referrnece var		class/interface		referrence var

1. there should be relation between type d and C either parent-child or child-parent or same type for conversion. otherwise compile error(inconvertable types found)
2. C should be same or derived type of A. otherwise compile time error(incompatible type)
3. underlying object type of d should be same as C or derived type of C.

Object o = new String("Hello")
StringBuffer sb = (StringBuffer)o;

1st rule pass
2nd rule pass
3rd rule failed 


Day7: Static control flow
1. Identification of static members from top to bottom (static var assigned default value = 0)
2. execution of static variable assignments and static blocks from top to bottom
3. Execution of main method

class base{

static int i = 10;
static{
m1();
Sopl("First static block");
}
p.s.v.m(String[] args){
m1();
Sopl("main method");
}
p.s.v.m1(){
Sopl(j);
}
static{
Sopl("Second static block");
}
static int j=20;
}

----javac base----
i=0[Read indirectly write only]
j=0[RIWO]
0
First static block
Second static block
20
main method

Note: var called from static block is direct read and var called from main method is indirect read. so if static var is just default read and called directly from static block then get compile time error.

class Base{						javac Base
							i=0[RIWO]
static int i = 10;
static{
Sopl(i);	---> direct read
}
p.s.v.m(String[] args){
Sopl(i);	---> indirect read
 }
}


day8: Constructors and access modifiers
main purpose of contructor is to initialize an object.


visibility						public		protected	default		private
within same class					yes		yes		yes		yes

child class of same package				yes		yes		yes		No

Non-child class of same pkg				yes		yes		yes		No

child class of outside pkg				yes		yes		No		No
							         [use only child ref]		
non-child class of outside pkg				yes		No		No		No


abstract method: only contains the declaration and child classes will provide implementation. 
class Loan{
public abstract double getInterestRates();
}

abstract class: partially implemented class. If class does not have complete implementation or contains abstract methods. Its not necessary to have abstract methods to  be abstract class. object cannot be created for abstract class. 

Interface: its a service requirement specification. Class is responsible for providing implementation for all methods in interface. 
Every method inside interface is public and abstract



Day9: Multi-threading: executing several tasks simultaneously.
(main objective--> inc performance + reduce processor idle time i.e response time)

1. Process based multi-tasking: 
executing several tasks simultaneously where each task is a separate independent pgm(process).
while typing java pgm in system, we can listen audio + downlaod a file from net all these tasks executed independently. best suitable for OS level. 

2. Thread based multi-tasking
executing several tasks simultaneously where each task is a separate independent part of same pgm(process). and each independent part is called thread. 
Best suitable at programatic level

Note: compared with old lang developing multi-threaded apps in java is easy as java provided inbuilt rich support for API.


2 ways to define a thread
1. extending Thread class

Class myThread extends Thread    # defines thread
{
  public void run(){
    -----------------
    -----------------   # job of thread
    }
}
Class MainThread{
p.s.v.m(Stringp[ args){
myThread t = new myThread();		--> instanciation of thread
t.start();		--> starting of thread
 }
}

Note: thread execution order we can't predict as its done by thread scheduler. t.start() method is responsible to create new thread and execute run method inside it. 
If we directly execute run() then it will run as normal method in main thread instead of creating new thread. 
2. overloading of run method is possibe but start() can invoke no-argument run method. other overloaded method have to call explicitely as normal method. 
3. If we override start(), our start method will execute as normal method without creating new thread.  
4. Once thread is started and we tried to start threas again then java throws runtime error as Illegal ThreadState Exception 

start(){
1. register thread with thread scheduler
2. perform all other mandatory activities
3. invoke run()
}


---Thread lifecyle-----
			      ________________			    ________________						  _________
 t = new myThread()--> |New/Born state| ----->t.start()----> |ready/runnable| --> thread scheduler allocates processor --> |running| --> run() completes--> |Dead|


2. implementing Runnable interface

